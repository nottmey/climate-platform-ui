# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"This directive allows results to be deferred during execution"
directive @defer on FIELD

"Tells the service this field/object has access authorized by an API key."
directive @aws_api_key on OBJECT | FIELD_DEFINITION

"Tells the service which subscriptions will be published to when this mutation is called. This directive is deprecated use @aws_susbscribe directive instead."
directive @aws_publish(
    "List of subscriptions which will be published to when this mutation is called."
    subscriptions: [String]
) on FIELD_DEFINITION

"Tells the service this field/object has access authorized by an OIDC token."
directive @aws_oidc on OBJECT | FIELD_DEFINITION

"Tells the service which mutation triggers this subscription."
directive @aws_subscribe(
    "List of mutations which will trigger this subscription when they are called."
    mutations: [String]
) on FIELD_DEFINITION

"Tells the service this field/object has access authorized by a Cognito User Pools token."
directive @aws_cognito_user_pools(
    "List of cognito user pool groups which have access on this field"
    cognito_groups: [String]
) on OBJECT | FIELD_DEFINITION

"Directs the schema to enforce authorization on a field"
directive @aws_auth(
    "List of cognito user pool groups which have access on this field"
    cognito_groups: [String]
) on FIELD_DEFINITION

"Tells the service this field/object has access authorized by sigv4 signing."
directive @aws_iam on OBJECT | FIELD_DEFINITION

"Tells the service this field/object has access authorized by a Lambda Authorizer."
directive @aws_lambda on OBJECT | FIELD_DEFINITION

" generated, do not edit manually!"
type Attribute {
    id: ID!
    name: String!
    type: String!
    values: [String!]!
}

" generated, do not edit manually!"
type Entity {
    attributes: [Attribute!]!
    context: AWSJSON
    id: ID!
}

" generated, do not edit manually!"
type EntityList {
    context: AWSJSON
    page(page: Int, size: Int): EntityListPage!
    total: Int!
}

" generated, do not edit manually!"
type EntityListPage {
    context: AWSJSON
    entities: [Entity!]!
    info: PageInfo!
}

" generated, do not edit manually!"
type Mutation {
    reset: [Entity!]!
}

" generated, do not edit manually!"
type PageInfo {
    current: Int!
    first: Int!
    last: Int!
    next: Int
    prev: Int
    size: Int!
}

" generated, do not edit manually!"
type Query {
    databases: [ID!]!
    get(database: ID!, id: ID!): Entity
    list(database: ID!): EntityList!
}

"The `AWSJSON` scalar type provided by AWS AppSync, represents a JSON string that complies with [RFC 8259](https://tools.ietf.org/html/rfc8259).  Maps like \"**{\\\\\"upvotes\\\\\": 10}**\", lists like \"**[1,2,3]**\", and scalar values like \"**\\\\\"AWSJSON example string\\\\\"**\", \"**1**\", and \"**true**\" are accepted as valid JSON and will automatically be parsed and loaded in the resolver mapping templates as Maps, Lists, or Scalar values rather than as the literal input strings.  Invalid JSON strings like \"**{a: 1}**\", \"**{'a': 1}**\" and \"**Unquoted string**\" will throw GraphQL validation errors."
scalar AWSJSON
