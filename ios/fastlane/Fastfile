# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins

require 'yaml'
require 'rbnacl'
require 'base64'
require 'octokit'
require 'spaceship'

opt_out_usage

default_platform(:ios)

key_id = ENV["APP_STORE_CONNECT_API_KEY_ID"]
app_store_connect_api_key(
  key_id: key_id,
  issuer_id: ENV["APP_STORE_CONNECT_ISSUER_ID"],
  key_filepath: File.expand_path("~/.private_keys/AuthKey_#{key_id}.p8")
)

def store_secret(secret_name, secret_value)
  repo = ENV['GITHUB_REPOSITORY']
  access_token = ENV['SECRET_SETTING_TOKEN']

  client = Octokit::Client.new(:access_token => access_token)
  public_key_response = client.get_actions_public_key(repo)
  key_id = public_key_response['key_id']
  decoded_key = Base64.decode64(public_key_response['key'])

  box = RbNaCl::Boxes::Sealed.from_public_key(decoded_key)
  encrypted_value = Base64.strict_encode64(box.encrypt(secret_value))

  client.create_or_update_actions_secret(repo, secret_name, {
    key_id: key_id,
    encrypted_value: encrypted_value
  })

  UI.success("Successfully set new value for secret #{secret_name}.")
end

def ensure_presence_of_valid_distribution_certificate()
  # setup local keychain
  keychain_path = File.expand_path("build.keychain")
  keychain_password = ""
  create_keychain(
    path: keychain_path,
    password: keychain_password,
    default_keychain: true,
    unlock: true,
    timeout: 3600
  )
  # setup distribution certificate in keychain
  certificate_id = get_certificates(
    # TODO prevent logging of certificates content
    # use force=true, if error happens because of expired certificate
    keychain_path: keychain_path,
    keychain_password: keychain_password
  )
  # upload resulting certificate key file to secrets
  certificate_key_file = "#{certificate_id}.p12"
  certificate_key_path = File.expand_path("../#{certificate_key_file}")
  raise "distribution certificate private key missing" unless File.exist?(certificate_key_path)
  certificate_key_content_hashed = sh("base64 -i #{certificate_key_path} | tr -d \\\\n", log: false)
  store_secret('APP_STORE_DISTRIBUTION_CERT_ID', certificate_id)
  store_secret('APP_STORE_DISTRIBUTION_CERT_KEY_FILE', certificate_key_content_hashed)
end

platform :ios do
  desc "Ensures that a valid distribution certificate is in keychain and backed up in secrets."
  lane :ensure_certificate do |options|
    ensure_presence_of_valid_distribution_certificate
  end

  desc "Requests, calculates and sets the next build version in the pubspec.yaml."
  lane :set_next_version_in_pubspec do |options|
    # TODO coordinate build number and version with android rollout
    latest_build_number = latest_testflight_build_number(initial_build_number: 0)
    # TODO allow increment (major, minor, patch) of version via options
    latest_version = lane_context[SharedValues::LATEST_TESTFLIGHT_VERSION]
    next_combined_version = "#{latest_version}+#{latest_build_number + 1}"
    UI.success("Next combined build version is #{next_combined_version}.")

    pubspec_path = "../../pubspec.yaml"
    pubspec = YAML.load_file(pubspec_path)
    pubspec['version'] = next_combined_version
    File.open(pubspec_path, 'w') { |file| YAML.dump(pubspec, file) }
  end

  desc "Builds and signs the app."
  lane :build do |options|
    ensure_presence_of_valid_distribution_certificate
    # always regenerate provisioning profile with current certificate
    profile_uuid = get_provisioning_profile(force: true)
    # disable automatic signing within pipeline (else it's great for devs)
    update_code_signing_settings(
      path: "Runner.xcodeproj",
      targets: ["Runner"],
      use_automatic_signing: false,
      code_sign_identity: "iPhone Distribution",
      profile_uuid: profile_uuid,
    )

    # if needed, also regenerate for additionally bundled extensions:
    # ex_profile_uuid = get_provisioning_profile(app_identifier: "bundle.id.ExampleExtension", force: true)
    # update_code_signing_settings(
    #   path: "Runner.xcodeproj",
    #   targets: ["ExampleExtension"],
    #   use_automatic_signing: false,
    #   code_sign_identity: "iPhone Distribution",
    #   profile_uuid: ex_profile_uuid,
    # )

    # build app including symbols
    build_app(
      workspace: "Runner.xcworkspace",
      scheme: "Runner",
      configuration: "Release",
      include_symbols: true
    )
  end

  desc "Uploads app and manages submission."
  lane :deploy do |options|
    upload_to_testflight(
      ipa: "Runner.ipa",
      distribute_external: true,
      groups: "Internal Testing, External Testing",
      changelog: "Happy Testing!"
    )
  end
end
